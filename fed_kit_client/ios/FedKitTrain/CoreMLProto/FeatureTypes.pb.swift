// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: FeatureTypes.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright (c) 2017, Apple Inc. All rights reserved.
//
// Use of this source code is governed by a BSD-3-clause license that can be
// found in LICENSE.txt or at https://opensource.org/licenses/BSD-3-Clause

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
private struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
    struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
    typealias Version = _2
}

/// *
/// The 64-bit integer feature type.
struct CoreML_Specification_Int64FeatureType {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

/// *
/// The double-precision floating point number feature type.
struct CoreML_Specification_DoubleFeatureType {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

/// *
/// The string feature type.
struct CoreML_Specification_StringFeatureType {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct CoreML_Specification_SizeRange {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var lowerBound: UInt64 = 0

    /// negative value means unbound otherwise upperbound is included in range
    var upperBound: Int64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

/// *
/// The image feature type.
struct CoreML_Specification_ImageFeatureType {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var width: Int64 = 0

    var height: Int64 = 0

    var sizeFlexibility: CoreML_Specification_ImageFeatureType.OneOf_SizeFlexibility?

    var enumeratedSizes: CoreML_Specification_ImageFeatureType.EnumeratedImageSizes {
        get {
            if case let .enumeratedSizes(v)? = sizeFlexibility { return v }
            return CoreML_Specification_ImageFeatureType.EnumeratedImageSizes()
        }
        set { sizeFlexibility = .enumeratedSizes(newValue) }
    }

    var imageSizeRange: CoreML_Specification_ImageFeatureType.ImageSizeRange {
        get {
            if case let .imageSizeRange(v)? = sizeFlexibility { return v }
            return CoreML_Specification_ImageFeatureType.ImageSizeRange()
        }
        set { sizeFlexibility = .imageSizeRange(newValue) }
    }

    var colorSpace: CoreML_Specification_ImageFeatureType.ColorSpace = .invalidColorSpace

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_SizeFlexibility: Equatable {
        case enumeratedSizes(CoreML_Specification_ImageFeatureType.EnumeratedImageSizes)
        case imageSizeRange(CoreML_Specification_ImageFeatureType.ImageSizeRange)

        #if !swift(>=4.1)
            static func == (lhs: CoreML_Specification_ImageFeatureType.OneOf_SizeFlexibility, rhs: CoreML_Specification_ImageFeatureType.OneOf_SizeFlexibility) -> Bool {
                // The use of inline closures is to circumvent an issue where the compiler
                // allocates stack space for every case branch when no optimizations are
                // enabled. https://github.com/apple/swift-protobuf/issues/1034
                switch (lhs, rhs) {
                case (.enumeratedSizes, .enumeratedSizes): return {
                        guard case let .enumeratedSizes(l) = lhs, case let .enumeratedSizes(r) = rhs else { preconditionFailure() }
                        return l == r
                    }()
                case (.imageSizeRange, .imageSizeRange): return {
                        guard case let .imageSizeRange(l) = lhs, case let .imageSizeRange(r) = rhs else { preconditionFailure() }
                        return l == r
                    }()
                default: return false
                }
            }
        #endif
    }

    /// Assumes raw (decompressed) format
    enum ColorSpace: SwiftProtobuf.Enum {
        typealias RawValue = Int
        case invalidColorSpace // = 0

        ///  8 bits per pixel
        case grayscale // = 10

        /// 32 bits per pixel: RGBA with A channel ignored
        case rgb // = 20

        /// 32 bits per pixel: BGRA with A channel ignored
        case bgr // = 30
        case UNRECOGNIZED(Int)

        init() {
            self = .invalidColorSpace
        }

        init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .invalidColorSpace
            case 10: self = .grayscale
            case 20: self = .rgb
            case 30: self = .bgr
            default: self = .UNRECOGNIZED(rawValue)
            }
        }

        var rawValue: Int {
            switch self {
            case .invalidColorSpace: return 0
            case .grayscale: return 10
            case .rgb: return 20
            case .bgr: return 30
            case let .UNRECOGNIZED(i): return i
            }
        }
    }

    struct ImageSize {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var width: UInt64 = 0

        var height: UInt64 = 0

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}
    }

    struct EnumeratedImageSizes {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var sizes: [CoreML_Specification_ImageFeatureType.ImageSize] = []

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}
    }

    struct ImageSizeRange {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var widthRange: CoreML_Specification_SizeRange {
            get { return _widthRange ?? CoreML_Specification_SizeRange() }
            set { _widthRange = newValue }
        }

        /// Returns true if `widthRange` has been explicitly set.
        var hasWidthRange: Bool { return self._widthRange != nil }
        /// Clears the value of `widthRange`. Subsequent reads from it will return its default value.
        mutating func clearWidthRange() { _widthRange = nil }

        var heightRange: CoreML_Specification_SizeRange {
            get { return _heightRange ?? CoreML_Specification_SizeRange() }
            set { _heightRange = newValue }
        }

        /// Returns true if `heightRange` has been explicitly set.
        var hasHeightRange: Bool { return self._heightRange != nil }
        /// Clears the value of `heightRange`. Subsequent reads from it will return its default value.
        mutating func clearHeightRange() { _heightRange = nil }

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}

        fileprivate var _widthRange: CoreML_Specification_SizeRange?
        fileprivate var _heightRange: CoreML_Specification_SizeRange?
    }

    init() {}
}

#if swift(>=4.2)

    extension CoreML_Specification_ImageFeatureType.ColorSpace: CaseIterable {
        // The compiler won't synthesize support with the UNRECOGNIZED case.
        static var allCases: [CoreML_Specification_ImageFeatureType.ColorSpace] = [
            .invalidColorSpace,
            .grayscale,
            .rgb,
            .bgr,
        ]
    }

#endif // swift(>=4.2)

/// *
/// The array feature type.
struct CoreML_Specification_ArrayFeatureType {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var shape: [Int64] = []

    var dataType: CoreML_Specification_ArrayFeatureType.ArrayDataType = .invalidArrayDataType

    var shapeFlexibility: CoreML_Specification_ArrayFeatureType.OneOf_ShapeFlexibility?

    var enumeratedShapes: CoreML_Specification_ArrayFeatureType.EnumeratedShapes {
        get {
            if case let .enumeratedShapes(v)? = shapeFlexibility { return v }
            return CoreML_Specification_ArrayFeatureType.EnumeratedShapes()
        }
        set { shapeFlexibility = .enumeratedShapes(newValue) }
    }

    var shapeRange: CoreML_Specification_ArrayFeatureType.ShapeRange {
        get {
            if case let .shapeRange(v)? = shapeFlexibility { return v }
            return CoreML_Specification_ArrayFeatureType.ShapeRange()
        }
        set { shapeFlexibility = .shapeRange(newValue) }
    }

    var defaultOptionalValue: CoreML_Specification_ArrayFeatureType.OneOf_DefaultOptionalValue?

    var intDefaultValue: Int32 {
        get {
            if case let .intDefaultValue(v)? = defaultOptionalValue { return v }
            return 0
        }
        set { defaultOptionalValue = .intDefaultValue(newValue) }
    }

    var floatDefaultValue: Float {
        get {
            if case let .floatDefaultValue(v)? = defaultOptionalValue { return v }
            return 0
        }
        set { defaultOptionalValue = .floatDefaultValue(newValue) }
    }

    var doubleDefaultValue: Double {
        get {
            if case let .doubleDefaultValue(v)? = defaultOptionalValue { return v }
            return 0
        }
        set { defaultOptionalValue = .doubleDefaultValue(newValue) }
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_ShapeFlexibility: Equatable {
        case enumeratedShapes(CoreML_Specification_ArrayFeatureType.EnumeratedShapes)
        case shapeRange(CoreML_Specification_ArrayFeatureType.ShapeRange)

        #if !swift(>=4.1)
            static func == (lhs: CoreML_Specification_ArrayFeatureType.OneOf_ShapeFlexibility, rhs: CoreML_Specification_ArrayFeatureType.OneOf_ShapeFlexibility) -> Bool {
                // The use of inline closures is to circumvent an issue where the compiler
                // allocates stack space for every case branch when no optimizations are
                // enabled. https://github.com/apple/swift-protobuf/issues/1034
                switch (lhs, rhs) {
                case (.enumeratedShapes, .enumeratedShapes): return {
                        guard case let .enumeratedShapes(l) = lhs, case let .enumeratedShapes(r) = rhs else { preconditionFailure() }
                        return l == r
                    }()
                case (.shapeRange, .shapeRange): return {
                        guard case let .shapeRange(l) = lhs, case let .shapeRange(r) = rhs else { preconditionFailure() }
                        return l == r
                    }()
                default: return false
                }
            }
        #endif
    }

    enum OneOf_DefaultOptionalValue: Equatable {
        case intDefaultValue(Int32)
        case floatDefaultValue(Float)
        case doubleDefaultValue(Double)

        #if !swift(>=4.1)
            static func == (lhs: CoreML_Specification_ArrayFeatureType.OneOf_DefaultOptionalValue, rhs: CoreML_Specification_ArrayFeatureType.OneOf_DefaultOptionalValue) -> Bool {
                // The use of inline closures is to circumvent an issue where the compiler
                // allocates stack space for every case branch when no optimizations are
                // enabled. https://github.com/apple/swift-protobuf/issues/1034
                switch (lhs, rhs) {
                case (.intDefaultValue, .intDefaultValue): return {
                        guard case let .intDefaultValue(l) = lhs, case let .intDefaultValue(r) = rhs else { preconditionFailure() }
                        return l == r
                    }()
                case (.floatDefaultValue, .floatDefaultValue): return {
                        guard case let .floatDefaultValue(l) = lhs, case let .floatDefaultValue(r) = rhs else { preconditionFailure() }
                        return l == r
                    }()
                case (.doubleDefaultValue, .doubleDefaultValue): return {
                        guard case let .doubleDefaultValue(l) = lhs, case let .doubleDefaultValue(r) = rhs else { preconditionFailure() }
                        return l == r
                    }()
                default: return false
                }
            }
        #endif
    }

    enum ArrayDataType: SwiftProtobuf.Enum {
        typealias RawValue = Int
        case invalidArrayDataType // = 0

        /// 0x10000 | 32
        case float32 // = 65568

        /// 0x10000 | 64
        case double // = 65600

        /// 0x20000 | 32
        case int32 // = 131104
        case UNRECOGNIZED(Int)

        init() {
            self = .invalidArrayDataType
        }

        init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .invalidArrayDataType
            case 65568: self = .float32
            case 65600: self = .double
            case 131_104: self = .int32
            default: self = .UNRECOGNIZED(rawValue)
            }
        }

        var rawValue: Int {
            switch self {
            case .invalidArrayDataType: return 0
            case .float32: return 65568
            case .double: return 65600
            case .int32: return 131_104
            case let .UNRECOGNIZED(i): return i
            }
        }
    }

    struct Shape {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var shape: [Int64] = []

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}
    }

    struct EnumeratedShapes {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var shapes: [CoreML_Specification_ArrayFeatureType.Shape] = []

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}
    }

    struct ShapeRange {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        /// sizeRanges.size() must be length 1 or 3
        /// sizeRanges[d] specifies the allowed range for dimension d
        var sizeRanges: [CoreML_Specification_SizeRange] = []

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}
    }

    init() {}
}

#if swift(>=4.2)

    extension CoreML_Specification_ArrayFeatureType.ArrayDataType: CaseIterable {
        // The compiler won't synthesize support with the UNRECOGNIZED case.
        static var allCases: [CoreML_Specification_ArrayFeatureType.ArrayDataType] = [
            .invalidArrayDataType,
            .float32,
            .double,
            .int32,
        ]
    }

#endif // swift(>=4.2)

/// *
/// The dictionary feature type.
struct CoreML_Specification_DictionaryFeatureType {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// *
    ///  Key/value type tags, with the following restrictions:
    ///  - ``keyType`` must be a hashable type
    ///  - ``valueType`` is assumed to be a ``double``
    var keyType: CoreML_Specification_DictionaryFeatureType.OneOf_KeyType?

    var int64KeyType: CoreML_Specification_Int64FeatureType {
        get {
            if case let .int64KeyType(v)? = keyType { return v }
            return CoreML_Specification_Int64FeatureType()
        }
        set { keyType = .int64KeyType(newValue) }
    }

    var stringKeyType: CoreML_Specification_StringFeatureType {
        get {
            if case let .stringKeyType(v)? = keyType { return v }
            return CoreML_Specification_StringFeatureType()
        }
        set { keyType = .stringKeyType(newValue) }
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    /// *
    ///  Key/value type tags, with the following restrictions:
    ///  - ``keyType`` must be a hashable type
    ///  - ``valueType`` is assumed to be a ``double``
    enum OneOf_KeyType: Equatable {
        case int64KeyType(CoreML_Specification_Int64FeatureType)
        case stringKeyType(CoreML_Specification_StringFeatureType)

        #if !swift(>=4.1)
            static func == (lhs: CoreML_Specification_DictionaryFeatureType.OneOf_KeyType, rhs: CoreML_Specification_DictionaryFeatureType.OneOf_KeyType) -> Bool {
                // The use of inline closures is to circumvent an issue where the compiler
                // allocates stack space for every case branch when no optimizations are
                // enabled. https://github.com/apple/swift-protobuf/issues/1034
                switch (lhs, rhs) {
                case (.int64KeyType, .int64KeyType): return {
                        guard case let .int64KeyType(l) = lhs, case let .int64KeyType(r) = rhs else { preconditionFailure() }
                        return l == r
                    }()
                case (.stringKeyType, .stringKeyType): return {
                        guard case let .stringKeyType(l) = lhs, case let .stringKeyType(r) = rhs else { preconditionFailure() }
                        return l == r
                    }()
                default: return false
                }
            }
        #endif
    }

    init() {}
}

/// *
/// The Sequence feature type.
struct CoreML_Specification_SequenceFeatureType {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// *
    /// Currently only categorical int64 and String sequences are supported
    var type: CoreML_Specification_SequenceFeatureType.OneOf_Type?

    var int64Type: CoreML_Specification_Int64FeatureType {
        get {
            if case let .int64Type(v)? = type { return v }
            return CoreML_Specification_Int64FeatureType()
        }
        set { type = .int64Type(newValue) }
    }

    var stringType: CoreML_Specification_StringFeatureType {
        get {
            if case let .stringType(v)? = type { return v }
            return CoreML_Specification_StringFeatureType()
        }
        set { type = .stringType(newValue) }
    }

    /// Range of allowed size/length/count of sequence
    var sizeRange: CoreML_Specification_SizeRange {
        get { return _sizeRange ?? CoreML_Specification_SizeRange() }
        set { _sizeRange = newValue }
    }

    /// Returns true if `sizeRange` has been explicitly set.
    var hasSizeRange: Bool { return self._sizeRange != nil }
    /// Clears the value of `sizeRange`. Subsequent reads from it will return its default value.
    mutating func clearSizeRange() { _sizeRange = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    /// *
    /// Currently only categorical int64 and String sequences are supported
    enum OneOf_Type: Equatable {
        case int64Type(CoreML_Specification_Int64FeatureType)
        case stringType(CoreML_Specification_StringFeatureType)

        #if !swift(>=4.1)
            static func == (lhs: CoreML_Specification_SequenceFeatureType.OneOf_Type, rhs: CoreML_Specification_SequenceFeatureType.OneOf_Type) -> Bool {
                // The use of inline closures is to circumvent an issue where the compiler
                // allocates stack space for every case branch when no optimizations are
                // enabled. https://github.com/apple/swift-protobuf/issues/1034
                switch (lhs, rhs) {
                case (.int64Type, .int64Type): return {
                        guard case let .int64Type(l) = lhs, case let .int64Type(r) = rhs else { preconditionFailure() }
                        return l == r
                    }()
                case (.stringType, .stringType): return {
                        guard case let .stringType(l) = lhs, case let .stringType(r) = rhs else { preconditionFailure() }
                        return l == r
                    }()
                default: return false
                }
            }
        #endif
    }

    init() {}

    fileprivate var _sizeRange: CoreML_Specification_SizeRange?
}

/// *
/// A feature, which may be optional.
struct CoreML_Specification_FeatureType {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var type: CoreML_Specification_FeatureType.OneOf_Type?

    var int64Type: CoreML_Specification_Int64FeatureType {
        get {
            if case let .int64Type(v)? = type { return v }
            return CoreML_Specification_Int64FeatureType()
        }
        set { type = .int64Type(newValue) }
    }

    var doubleType: CoreML_Specification_DoubleFeatureType {
        get {
            if case let .doubleType(v)? = type { return v }
            return CoreML_Specification_DoubleFeatureType()
        }
        set { type = .doubleType(newValue) }
    }

    var stringType: CoreML_Specification_StringFeatureType {
        get {
            if case let .stringType(v)? = type { return v }
            return CoreML_Specification_StringFeatureType()
        }
        set { type = .stringType(newValue) }
    }

    var imageType: CoreML_Specification_ImageFeatureType {
        get {
            if case let .imageType(v)? = type { return v }
            return CoreML_Specification_ImageFeatureType()
        }
        set { type = .imageType(newValue) }
    }

    var multiArrayType: CoreML_Specification_ArrayFeatureType {
        get {
            if case let .multiArrayType(v)? = type { return v }
            return CoreML_Specification_ArrayFeatureType()
        }
        set { type = .multiArrayType(newValue) }
    }

    var dictionaryType: CoreML_Specification_DictionaryFeatureType {
        get {
            if case let .dictionaryType(v)? = type { return v }
            return CoreML_Specification_DictionaryFeatureType()
        }
        set { type = .dictionaryType(newValue) }
    }

    var sequenceType: CoreML_Specification_SequenceFeatureType {
        get {
            if case let .sequenceType(v)? = type { return v }
            return CoreML_Specification_SequenceFeatureType()
        }
        set { type = .sequenceType(newValue) }
    }

    var isOptional: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Type: Equatable {
        case int64Type(CoreML_Specification_Int64FeatureType)
        case doubleType(CoreML_Specification_DoubleFeatureType)
        case stringType(CoreML_Specification_StringFeatureType)
        case imageType(CoreML_Specification_ImageFeatureType)
        case multiArrayType(CoreML_Specification_ArrayFeatureType)
        case dictionaryType(CoreML_Specification_DictionaryFeatureType)
        case sequenceType(CoreML_Specification_SequenceFeatureType)

        #if !swift(>=4.1)
            static func == (lhs: CoreML_Specification_FeatureType.OneOf_Type, rhs: CoreML_Specification_FeatureType.OneOf_Type) -> Bool {
                // The use of inline closures is to circumvent an issue where the compiler
                // allocates stack space for every case branch when no optimizations are
                // enabled. https://github.com/apple/swift-protobuf/issues/1034
                switch (lhs, rhs) {
                case (.int64Type, .int64Type): return {
                        guard case let .int64Type(l) = lhs, case let .int64Type(r) = rhs else { preconditionFailure() }
                        return l == r
                    }()
                case (.doubleType, .doubleType): return {
                        guard case let .doubleType(l) = lhs, case let .doubleType(r) = rhs else { preconditionFailure() }
                        return l == r
                    }()
                case (.stringType, .stringType): return {
                        guard case let .stringType(l) = lhs, case let .stringType(r) = rhs else { preconditionFailure() }
                        return l == r
                    }()
                case (.imageType, .imageType): return {
                        guard case let .imageType(l) = lhs, case let .imageType(r) = rhs else { preconditionFailure() }
                        return l == r
                    }()
                case (.multiArrayType, .multiArrayType): return {
                        guard case let .multiArrayType(l) = lhs, case let .multiArrayType(r) = rhs else { preconditionFailure() }
                        return l == r
                    }()
                case (.dictionaryType, .dictionaryType): return {
                        guard case let .dictionaryType(l) = lhs, case let .dictionaryType(r) = rhs else { preconditionFailure() }
                        return l == r
                    }()
                case (.sequenceType, .sequenceType): return {
                        guard case let .sequenceType(l) = lhs, case let .sequenceType(r) = rhs else { preconditionFailure() }
                        return l == r
                    }()
                default: return false
                }
            }
        #endif
    }

    init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

private let _protobuf_package = "CoreML.Specification"

extension CoreML_Specification_Int64FeatureType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".Int64FeatureType"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let _ = try decoder.nextFieldNumber() {}
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: CoreML_Specification_Int64FeatureType, rhs: CoreML_Specification_Int64FeatureType) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension CoreML_Specification_DoubleFeatureType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".DoubleFeatureType"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let _ = try decoder.nextFieldNumber() {}
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: CoreML_Specification_DoubleFeatureType, rhs: CoreML_Specification_DoubleFeatureType) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension CoreML_Specification_StringFeatureType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".StringFeatureType"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let _ = try decoder.nextFieldNumber() {}
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: CoreML_Specification_StringFeatureType, rhs: CoreML_Specification_StringFeatureType) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension CoreML_Specification_SizeRange: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".SizeRange"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "lowerBound"),
        2: .same(proto: "upperBound"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularUInt64Field(value: &lowerBound)
            case 2: try try decoder.decodeSingularInt64Field(value: &upperBound)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if lowerBound != 0 {
            try visitor.visitSingularUInt64Field(value: lowerBound, fieldNumber: 1)
        }
        if upperBound != 0 {
            try visitor.visitSingularInt64Field(value: upperBound, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: CoreML_Specification_SizeRange, rhs: CoreML_Specification_SizeRange) -> Bool {
        if lhs.lowerBound != rhs.lowerBound { return false }
        if lhs.upperBound != rhs.upperBound { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension CoreML_Specification_ImageFeatureType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ImageFeatureType"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "width"),
        2: .same(proto: "height"),
        21: .same(proto: "enumeratedSizes"),
        31: .same(proto: "imageSizeRange"),
        3: .same(proto: "colorSpace"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularInt64Field(value: &width)
            case 2: try try decoder.decodeSingularInt64Field(value: &height)
            case 3: try try decoder.decodeSingularEnumField(value: &colorSpace)
            case 21: try {
                    var v: CoreML_Specification_ImageFeatureType.EnumeratedImageSizes?
                    var hadOneofValue = false
                    if let current = self.sizeFlexibility {
                        hadOneofValue = true
                        if case let .enumeratedSizes(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.sizeFlexibility = .enumeratedSizes(v)
                    }
                }()
            case 31: try {
                    var v: CoreML_Specification_ImageFeatureType.ImageSizeRange?
                    var hadOneofValue = false
                    if let current = self.sizeFlexibility {
                        hadOneofValue = true
                        if case let .imageSizeRange(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.sizeFlexibility = .imageSizeRange(v)
                    }
                }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if width != 0 {
            try visitor.visitSingularInt64Field(value: width, fieldNumber: 1)
        }
        if height != 0 {
            try visitor.visitSingularInt64Field(value: height, fieldNumber: 2)
        }
        if colorSpace != .invalidColorSpace {
            try visitor.visitSingularEnumField(value: colorSpace, fieldNumber: 3)
        }
        switch sizeFlexibility {
        case .enumeratedSizes?: try {
                guard case let .enumeratedSizes(v)? = self.sizeFlexibility else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
            }()
        case .imageSizeRange?: try {
                guard case let .imageSizeRange(v)? = self.sizeFlexibility else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 31)
            }()
        case nil: break
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: CoreML_Specification_ImageFeatureType, rhs: CoreML_Specification_ImageFeatureType) -> Bool {
        if lhs.width != rhs.width { return false }
        if lhs.height != rhs.height { return false }
        if lhs.sizeFlexibility != rhs.sizeFlexibility { return false }
        if lhs.colorSpace != rhs.colorSpace { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension CoreML_Specification_ImageFeatureType.ColorSpace: SwiftProtobuf._ProtoNameProviding {
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "INVALID_COLOR_SPACE"),
        10: .same(proto: "GRAYSCALE"),
        20: .same(proto: "RGB"),
        30: .same(proto: "BGR"),
    ]
}

extension CoreML_Specification_ImageFeatureType.ImageSize: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = CoreML_Specification_ImageFeatureType.protoMessageName + ".ImageSize"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "width"),
        2: .same(proto: "height"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularUInt64Field(value: &width)
            case 2: try try decoder.decodeSingularUInt64Field(value: &height)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if width != 0 {
            try visitor.visitSingularUInt64Field(value: width, fieldNumber: 1)
        }
        if height != 0 {
            try visitor.visitSingularUInt64Field(value: height, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: CoreML_Specification_ImageFeatureType.ImageSize, rhs: CoreML_Specification_ImageFeatureType.ImageSize) -> Bool {
        if lhs.width != rhs.width { return false }
        if lhs.height != rhs.height { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension CoreML_Specification_ImageFeatureType.EnumeratedImageSizes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = CoreML_Specification_ImageFeatureType.protoMessageName + ".EnumeratedImageSizes"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "sizes"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeRepeatedMessageField(value: &sizes)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !sizes.isEmpty {
            try visitor.visitRepeatedMessageField(value: sizes, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: CoreML_Specification_ImageFeatureType.EnumeratedImageSizes, rhs: CoreML_Specification_ImageFeatureType.EnumeratedImageSizes) -> Bool {
        if lhs.sizes != rhs.sizes { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension CoreML_Specification_ImageFeatureType.ImageSizeRange: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = CoreML_Specification_ImageFeatureType.protoMessageName + ".ImageSizeRange"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "widthRange"),
        2: .same(proto: "heightRange"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeSingularMessageField(value: &_widthRange)
            case 2: try try decoder.decodeSingularMessageField(value: &_heightRange)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._widthRange {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        try { if let v = self._heightRange {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: CoreML_Specification_ImageFeatureType.ImageSizeRange, rhs: CoreML_Specification_ImageFeatureType.ImageSizeRange) -> Bool {
        if lhs._widthRange != rhs._widthRange { return false }
        if lhs._heightRange != rhs._heightRange { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension CoreML_Specification_ArrayFeatureType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ArrayFeatureType"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "shape"),
        2: .same(proto: "dataType"),
        21: .same(proto: "enumeratedShapes"),
        31: .same(proto: "shapeRange"),
        41: .same(proto: "intDefaultValue"),
        51: .same(proto: "floatDefaultValue"),
        61: .same(proto: "doubleDefaultValue"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeRepeatedInt64Field(value: &shape)
            case 2: try try decoder.decodeSingularEnumField(value: &dataType)
            case 21: try {
                    var v: CoreML_Specification_ArrayFeatureType.EnumeratedShapes?
                    var hadOneofValue = false
                    if let current = self.shapeFlexibility {
                        hadOneofValue = true
                        if case let .enumeratedShapes(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.shapeFlexibility = .enumeratedShapes(v)
                    }
                }()
            case 31: try {
                    var v: CoreML_Specification_ArrayFeatureType.ShapeRange?
                    var hadOneofValue = false
                    if let current = self.shapeFlexibility {
                        hadOneofValue = true
                        if case let .shapeRange(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.shapeFlexibility = .shapeRange(v)
                    }
                }()
            case 41: try {
                    var v: Int32?
                    try decoder.decodeSingularInt32Field(value: &v)
                    if let v = v {
                        if self.defaultOptionalValue != nil { try decoder.handleConflictingOneOf() }
                        self.defaultOptionalValue = .intDefaultValue(v)
                    }
                }()
            case 51: try {
                    var v: Float?
                    try decoder.decodeSingularFloatField(value: &v)
                    if let v = v {
                        if self.defaultOptionalValue != nil { try decoder.handleConflictingOneOf() }
                        self.defaultOptionalValue = .floatDefaultValue(v)
                    }
                }()
            case 61: try {
                    var v: Double?
                    try decoder.decodeSingularDoubleField(value: &v)
                    if let v = v {
                        if self.defaultOptionalValue != nil { try decoder.handleConflictingOneOf() }
                        self.defaultOptionalValue = .doubleDefaultValue(v)
                    }
                }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !shape.isEmpty {
            try visitor.visitPackedInt64Field(value: shape, fieldNumber: 1)
        }
        if dataType != .invalidArrayDataType {
            try visitor.visitSingularEnumField(value: dataType, fieldNumber: 2)
        }
        switch shapeFlexibility {
        case .enumeratedShapes?: try {
                guard case let .enumeratedShapes(v)? = self.shapeFlexibility else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
            }()
        case .shapeRange?: try {
                guard case let .shapeRange(v)? = self.shapeFlexibility else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 31)
            }()
        case nil: break
        }
        switch defaultOptionalValue {
        case .intDefaultValue?: try {
                guard case let .intDefaultValue(v)? = self.defaultOptionalValue else { preconditionFailure() }
                try visitor.visitSingularInt32Field(value: v, fieldNumber: 41)
            }()
        case .floatDefaultValue?: try {
                guard case let .floatDefaultValue(v)? = self.defaultOptionalValue else { preconditionFailure() }
                try visitor.visitSingularFloatField(value: v, fieldNumber: 51)
            }()
        case .doubleDefaultValue?: try {
                guard case let .doubleDefaultValue(v)? = self.defaultOptionalValue else { preconditionFailure() }
                try visitor.visitSingularDoubleField(value: v, fieldNumber: 61)
            }()
        case nil: break
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: CoreML_Specification_ArrayFeatureType, rhs: CoreML_Specification_ArrayFeatureType) -> Bool {
        if lhs.shape != rhs.shape { return false }
        if lhs.dataType != rhs.dataType { return false }
        if lhs.shapeFlexibility != rhs.shapeFlexibility { return false }
        if lhs.defaultOptionalValue != rhs.defaultOptionalValue { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension CoreML_Specification_ArrayFeatureType.ArrayDataType: SwiftProtobuf._ProtoNameProviding {
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "INVALID_ARRAY_DATA_TYPE"),
        65568: .same(proto: "FLOAT32"),
        65600: .same(proto: "DOUBLE"),
        131_104: .same(proto: "INT32"),
    ]
}

extension CoreML_Specification_ArrayFeatureType.Shape: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = CoreML_Specification_ArrayFeatureType.protoMessageName + ".Shape"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "shape"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeRepeatedInt64Field(value: &shape)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !shape.isEmpty {
            try visitor.visitPackedInt64Field(value: shape, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: CoreML_Specification_ArrayFeatureType.Shape, rhs: CoreML_Specification_ArrayFeatureType.Shape) -> Bool {
        if lhs.shape != rhs.shape { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension CoreML_Specification_ArrayFeatureType.EnumeratedShapes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = CoreML_Specification_ArrayFeatureType.protoMessageName + ".EnumeratedShapes"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "shapes"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeRepeatedMessageField(value: &shapes)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !shapes.isEmpty {
            try visitor.visitRepeatedMessageField(value: shapes, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: CoreML_Specification_ArrayFeatureType.EnumeratedShapes, rhs: CoreML_Specification_ArrayFeatureType.EnumeratedShapes) -> Bool {
        if lhs.shapes != rhs.shapes { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension CoreML_Specification_ArrayFeatureType.ShapeRange: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = CoreML_Specification_ArrayFeatureType.protoMessageName + ".ShapeRange"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "sizeRanges"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try try decoder.decodeRepeatedMessageField(value: &sizeRanges)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !sizeRanges.isEmpty {
            try visitor.visitRepeatedMessageField(value: sizeRanges, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: CoreML_Specification_ArrayFeatureType.ShapeRange, rhs: CoreML_Specification_ArrayFeatureType.ShapeRange) -> Bool {
        if lhs.sizeRanges != rhs.sizeRanges { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension CoreML_Specification_DictionaryFeatureType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".DictionaryFeatureType"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "int64KeyType"),
        2: .same(proto: "stringKeyType"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try {
                    var v: CoreML_Specification_Int64FeatureType?
                    var hadOneofValue = false
                    if let current = self.keyType {
                        hadOneofValue = true
                        if case let .int64KeyType(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.keyType = .int64KeyType(v)
                    }
                }()
            case 2: try {
                    var v: CoreML_Specification_StringFeatureType?
                    var hadOneofValue = false
                    if let current = self.keyType {
                        hadOneofValue = true
                        if case let .stringKeyType(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.keyType = .stringKeyType(v)
                    }
                }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        switch keyType {
        case .int64KeyType?: try {
                guard case let .int64KeyType(v)? = self.keyType else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
            }()
        case .stringKeyType?: try {
                guard case let .stringKeyType(v)? = self.keyType else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
            }()
        case nil: break
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: CoreML_Specification_DictionaryFeatureType, rhs: CoreML_Specification_DictionaryFeatureType) -> Bool {
        if lhs.keyType != rhs.keyType { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension CoreML_Specification_SequenceFeatureType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".SequenceFeatureType"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "int64Type"),
        3: .same(proto: "stringType"),
        101: .same(proto: "sizeRange"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try {
                    var v: CoreML_Specification_Int64FeatureType?
                    var hadOneofValue = false
                    if let current = self.type {
                        hadOneofValue = true
                        if case let .int64Type(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.type = .int64Type(v)
                    }
                }()
            case 3: try {
                    var v: CoreML_Specification_StringFeatureType?
                    var hadOneofValue = false
                    if let current = self.type {
                        hadOneofValue = true
                        if case let .stringType(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.type = .stringType(v)
                    }
                }()
            case 101: try try decoder.decodeSingularMessageField(value: &_sizeRange)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        switch type {
        case .int64Type?: try {
                guard case let .int64Type(v)? = self.type else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
            }()
        case .stringType?: try {
                guard case let .stringType(v)? = self.type else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
            }()
        case nil: break
        }
        try { if let v = self._sizeRange {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 101)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: CoreML_Specification_SequenceFeatureType, rhs: CoreML_Specification_SequenceFeatureType) -> Bool {
        if lhs.type != rhs.type { return false }
        if lhs._sizeRange != rhs._sizeRange { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension CoreML_Specification_FeatureType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".FeatureType"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "int64Type"),
        2: .same(proto: "doubleType"),
        3: .same(proto: "stringType"),
        4: .same(proto: "imageType"),
        5: .same(proto: "multiArrayType"),
        6: .same(proto: "dictionaryType"),
        7: .same(proto: "sequenceType"),
        1000: .same(proto: "isOptional"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try {
                    var v: CoreML_Specification_Int64FeatureType?
                    var hadOneofValue = false
                    if let current = self.type {
                        hadOneofValue = true
                        if case let .int64Type(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.type = .int64Type(v)
                    }
                }()
            case 2: try {
                    var v: CoreML_Specification_DoubleFeatureType?
                    var hadOneofValue = false
                    if let current = self.type {
                        hadOneofValue = true
                        if case let .doubleType(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.type = .doubleType(v)
                    }
                }()
            case 3: try {
                    var v: CoreML_Specification_StringFeatureType?
                    var hadOneofValue = false
                    if let current = self.type {
                        hadOneofValue = true
                        if case let .stringType(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.type = .stringType(v)
                    }
                }()
            case 4: try {
                    var v: CoreML_Specification_ImageFeatureType?
                    var hadOneofValue = false
                    if let current = self.type {
                        hadOneofValue = true
                        if case let .imageType(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.type = .imageType(v)
                    }
                }()
            case 5: try {
                    var v: CoreML_Specification_ArrayFeatureType?
                    var hadOneofValue = false
                    if let current = self.type {
                        hadOneofValue = true
                        if case let .multiArrayType(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.type = .multiArrayType(v)
                    }
                }()
            case 6: try {
                    var v: CoreML_Specification_DictionaryFeatureType?
                    var hadOneofValue = false
                    if let current = self.type {
                        hadOneofValue = true
                        if case let .dictionaryType(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.type = .dictionaryType(v)
                    }
                }()
            case 7: try {
                    var v: CoreML_Specification_SequenceFeatureType?
                    var hadOneofValue = false
                    if let current = self.type {
                        hadOneofValue = true
                        if case let .sequenceType(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.type = .sequenceType(v)
                    }
                }()
            case 1000: try try decoder.decodeSingularBoolField(value: &isOptional)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        switch type {
        case .int64Type?: try {
                guard case let .int64Type(v)? = self.type else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
            }()
        case .doubleType?: try {
                guard case let .doubleType(v)? = self.type else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
            }()
        case .stringType?: try {
                guard case let .stringType(v)? = self.type else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
            }()
        case .imageType?: try {
                guard case let .imageType(v)? = self.type else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
            }()
        case .multiArrayType?: try {
                guard case let .multiArrayType(v)? = self.type else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
            }()
        case .dictionaryType?: try {
                guard case let .dictionaryType(v)? = self.type else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
            }()
        case .sequenceType?: try {
                guard case let .sequenceType(v)? = self.type else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
            }()
        case nil: break
        }
        if isOptional != false {
            try visitor.visitSingularBoolField(value: isOptional, fieldNumber: 1000)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: CoreML_Specification_FeatureType, rhs: CoreML_Specification_FeatureType) -> Bool {
        if lhs.type != rhs.type { return false }
        if lhs.isOptional != rhs.isOptional { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}
